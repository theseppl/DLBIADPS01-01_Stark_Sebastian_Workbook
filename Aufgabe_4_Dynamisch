class DPActivitySelector:
    def __init__(self, activities):
        self.activities = activities

    def select_activities(self):
        # Sortiere Aktivitäten nach Endzeit
        self.activities.sort(key=lambda x: x[1])
        n = len(self.activities)

        # Erstelle DP-Array: dp[i] speichert die maximale Anzahl Aktivitäten bis zur i-ten Aktivität
        dp = [0] * n
        prev = [-1] * n  # Für die Rückverfolgung der Aktivitäten
        dp[0] = 1  # Die erste Aktivität kann immer gewählt werden

        for i in range(1, n):
            # Möglichkeit 1: Diese Aktivität wählen
            include = 1
            last_non_conflicting = -1
            for j in range(i - 1, -1, -1):
                if self.activities[j][1] <= self.activities[i][0]:  # Keine Überschneidung
                    include += dp[j]
                    last_non_conflicting = j
                    break

            # Möglichkeit 2: Diese Aktivität ignorieren
            exclude = dp[i - 1]

            # Wähle die bessere Möglichkeit und speichere die Entscheidung
            if include > exclude:
                dp[i] = include
                prev[i] = last_non_conflicting
            else:
                dp[i] = exclude
                prev[i] = prev[i - 1]

        # Rekonstruiere die Liste der ausgewählten Aktivitäten
        selected_activities = []
        i = n - 1
        while i >= 0:
            if prev[i] != prev[i - 1]:  # Diese Aktivität wurde gewählt
                selected_activities.append(self.activities[i])
                i = prev[i]
            else:
                i -= 1

        selected_activities.reverse()  # Aktivitäten in chronologischer Reihenfolge ausgeben
        return dp[-1], selected_activities

# Beispiel
activities = [(2, 4), (2, 5), (5, 6), (6, 8), (1, 6)]
selector = DPActivitySelector(activities)
max_activities, selected_activities = selector.select_activities()
print("Maximale Anzahl Aktivitäten (Dynamisch):", max_activities)
print("Ausgewählte Aktivitäten:", selected_activities)

